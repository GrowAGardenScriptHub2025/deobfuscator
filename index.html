<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lua Deobfuscator + Caesar Decode</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"></script>
<style>
  @keyframes slideIn {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }
  .animate-slide-in {
    animation: slideIn 0.5s ease-out forwards;
  }
  .editor {
    height: 300px;
    width: 100%;
    border-radius: 0.5rem;
    border: 1px solid #4b5563;
    background-color: #1f2937;
    color: #d1d5db;
  }
  .log-entry {
    transition: all 0.3s ease;
  }
  .log-entry:hover {
    background-color: #374151;
  }
  .card {
    background-color: #2d3748;
    border-radius: 0.5rem;
    padding: 1rem;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
</style>
</head>
<body class="bg-gray-900 text-white min-h-screen p-6">
  <div class="container mx-auto max-w-6xl">
    <h1 class="text-3xl font-bold text-center mb-6 animate-slide-in">Lua Deobfuscator + Caesar Decode</h1>
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
      <!-- Input Section -->
      <div class="card animate-slide-in" style="animation-delay: 0.1s;">
        <h2 class="text-xl font-semibold mb-2">Input Payload</h2>
        <p class="text-gray-400 mb-4 text-sm">Paste your obfuscated Lua script or encoded payload here</p>
        <div id="inputEditor" class="editor"></div>
        <button id="decodeBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded-lg mt-4 w-full transition duration-300 flex items-center justify-center">
          <span class="mr-2">üîç</span> Decode Payload
        </button>
      </div>
      <!-- Output Section -->
      <div class="card animate-slide-in" style="animation-delay: 0.2s;">
        <h2 class="text-xl font-semibold mb-2">Decoded Output</h2>
        <p class="text-gray-400 mb-4 text-sm">Reconstructed Lua script will appear here...</p>
        <div id="outputEditor" class="editor"></div>
      </div>
    </div>
    <!-- Decoding Process Section -->
    <div class="card animate-slide-in" style="animation-delay: 0.3s;">
      <h2 class="text-xl font-semibold mb-2">Decoding Process</h2>
      <p class="text-gray-400 mb-4 text-sm">Step-by-step breakdown of the decoding process</p>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <h3 class="text-md font-medium mb-2">Decoding Steps</h3>
          <div id="logs" class="bg-gray-800 p-2 rounded-lg h-32 overflow-y-auto text-sm"></div>
        </div>
        <div>
          <h3 class="text-md font-medium mb-2">Extracted URLs</h3>
          <div id="urlList" class="bg-gray-800 p-2 rounded-lg h-32 overflow-y-auto text-sm text-gray-400"></div>
        </div>
        <div>
          <h3 class="text-md font-medium mb-2">Tool Information</h3>
          <div class="bg-gray-800 p-2 rounded-lg h-32 overflow-y-auto text-sm text-gray-400">
            <p><strong>Supported Patterns:</strong></p>
            <ul class="list-disc list-inside text-sm">
              <li>LOL! ... - Custom encoded payloads</li>
              <li>\x## - Hexadecimal escape sequences</li>
              <li>\### - Octal escape sequences</li>
              <li>string.char() - Character code functions</li>
              <li>XOR encoded data</li>
              <li>Caesar cipher (+5 shift) encoded strings (with % for .)</li>
            </ul>
            <p class="mt-2"><strong>Decoding Functions:</strong></p>
            <ul class="list-disc list-inside text-sm">
              <li>v15: Pattern-based hex extraction</li>
              <li>v28: Bytecode interpretation simulation</li>
              <li>v32: Lua script reconstruction + Caesar decode</li>
            </ul>
            <p class="mt-2"><strong>Error Handling:</strong></p>
            <p>The tool includes comprehensive error handling for malformed payloads, invalid hex sequences, and bytecode interpretation issues.</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Initialize ACE editors
    const inputEditor = ace.edit("inputEditor");
    inputEditor.setTheme("ace/theme/monokai");
    inputEditor.session.setMode("ace/mode/lua");
    inputEditor.setOptions({ fontSize: "14px" });

    const outputEditor = ace.edit("outputEditor");
    outputEditor.setTheme("ace/theme/monokai");
    outputEditor.session.setMode("ace/mode/lua");
    outputEditor.setOptions({ fontSize: "14px", readOnly: true });

    // XOR decoding function
    function xorDecode(input, key) {
      // Handle escaped sequences (e.g., \123) by converting to char codes
      let processedInput = input.replace(/\\(\d{1,3})/g, (match, num) => String.fromCharCode(parseInt(num)));

      // XOR each character with the numeric key
      return processedInput.split('').map(char => {
        const charCode = char.charCodeAt(0);
        const xoredCode = charCode ^ key;
        return String.fromCharCode(xoredCode);
      }).join('');
    }

    // Function to find XOR key by brute force
    function findXorKey(input) {
      const validTextPatterns = [/^http/, /\b\w{3,}\b/]; // Check for URLs or readable words
      let bestKey = null;
      let bestResult = "";

      for (let key = 0; key <= 255; key++) {
        const decoded = xorDecode(input, key);
        if (validTextPatterns.some(pattern => pattern.test(decoded))) {
          bestKey = key;
          bestResult = decoded;
          break; // Stop at first valid match
        }
      }

      return { key: bestKey, result: bestResult || "No valid key found" };
    }

    // Caesar decode function (shift letters/digits backward by shift)
    function caesarDecode(str, shift) {
      return str.split('').map(ch => {
        const code = ch.charCodeAt(0);
        // A-Z
        if (code >= 65 && code <= 90) {
          return String.fromCharCode((code - 65 - shift + 26) % 26 + 65);
        }
        // a-z
        if (code >= 97 && code <= 122) {
          return String.fromCharCode((code - 97 - shift + 26) % 26 + 97);
        }
        // 0-9
        if (code >= 48 && code <= 57) {
          return String.fromCharCode((code - 48 - shift + 10) % 10 + 48);
        }
        // else unchanged
        return ch;
      }).join('').replace(/%/g, '.'); // Replace % with .
    }

    // Deobfuscation logic
    function deobfuscate(code) {
      const logs = [];
      let deobfuscated = code;

      try {
        // Handle LOL! pattern
        if (deobfuscated.startsWith("LOL!")) {
          logs.push("Detected LOL! pattern, initiating custom payload decoding");
          deobfuscated = deobfuscated.replace(/LOL!(\w+)/, (match, payload) => {
            return `function decoded() return "${payload}" end`;
          });
        }

        // Decode hexadecimal escape sequences
        deobfuscated = deobfuscated.replace(/\\x([0-9A-Fa-f]{2})/g, (match, hex) => {
          logs.push(`Decoded hex sequence \\x${hex} to ${String.fromCharCode(parseInt(hex, 16))}`);
          return String.fromCharCode(parseInt(hex, 16));
        });

        // Decode octal escape sequences
        deobfuscated = deobfuscated.replace(/\\([0-7]{1,3})/g, (match, oct) => {
          logs.push(`Decoded octal sequence \\${oct} to ${String.fromCharCode(parseInt(oct, 8))}`);
          return String.fromCharCode(parseInt(oct, 8));
        });

        // Decode string.char(...) sequences (simple)
        deobfuscated = deobfuscated.replace(/string\.char\(([\d,\s]+)\)/g, (match, nums) => {
          const chars = nums.split(',').map(n => String.fromCharCode(parseInt(n.trim()))).join('');
          logs.push(`Decoded string.char(...) to "${chars}"`);
          return chars;
        });

        // XOR decoding with key search if "XOR:" is detected
        if (deobfuscated.includes("XOR:")) {
          logs.push("Detected XOR encoded data, attempting to find key");
          const xorMatch = deobfuscated.match(/XOR:([\w\\]+)/);
          if (xorMatch) {
            const xorData = xorMatch[1];
            const { key, result } = findXorKey(xorData);
            if (key !== null) {
              logs.push(`Found XOR key ${key}, decoded "${xorData}" to "${result}"`);
              deobfuscated = deobfuscated.replace(/XOR:[\w\\]+/, result);
            } else {
              logs.push("No valid XOR key found");
            }
          }
        }

        // Caesar cipher +5 decoding detection (simple heuristic)
        // Check if code has common caesar-encoded substrings:
        const caesarIndicators = ["mnuux", "numjw", "tqxxj"]; // sample encoded words from example
        if (caesarIndicators.some(ind => deobfuscated.includes(ind))) {
          logs.push("Detected Caesar +5 encoded string, decoding");
          // Attempt to decode all % replaced with .
          deobfuscated = caesarDecode(deobfuscated, 5);
          logs.push("Caesar decoding applied (+5 shift, %‚Üí.)");
        }

        // Extract URLs
        const urlRegex = /https?:\/\/[^\s'"]+/g;
        const urls = deobfuscated.match(urlRegex) || [];

        // Format code (basic indent)
        const lines = deobfuscated.split("\n");
        let indentLevel = 0;
        deobfuscated = lines.map(line => {
          line = line.trim();
          if (line.match(/end$/)) indentLevel = Math.max(0, indentLevel - 1);
          const indented = "  ".repeat(indentLevel) + line;
          if (line.match(/do$|then$|function/)) indentLevel++;
          return indented;
        }).join("\n");
        logs.push("Applied basic code formatting");

        return { deobfuscated, logs, urls };
      } catch (e) {
        logs.push(`Error during deobfuscation: ${e.message}`);
      }

      return { deobfuscated, logs, urls: [] };
    }

    // Update logs
    function updateLogs(logs) {
      const logsDiv = document.getElementById("logs");
      logsDiv.innerHTML = logs.length ? logs.map(log => `<div class="log-entry p-1">${log}</div>`).join("") : "<div class='p-1 text-gray-500'>No decoding steps yet. Enter a payload and click decode.</div>";
      logsDiv.scrollTop = logsDiv.scrollHeight;
    }

    // Update URLs
    function updateUrls(urls) {
      const urlList = document.getElementById("urlList");
      urlList.innerHTML = urls.length ? urls.map(url => `<div class="p-1"><a href="${url}" target="_blank" class="text-blue-400 hover:underline">${url}</a></div>`).join("") : "<div class='p-1 text-gray-500'>No URLs extracted.</div>";
    }

    // Decode button click handler
    document.getElementById("decodeBtn").addEventListener("click", () => {
      const inputCode = inputEditor.getValue().trim();
      if (!inputCode) {
        updateLogs(["No input code provided"]);
        updateUrls([]);
        return;
      }

      const { deobfuscated, logs, urls } = deobfuscate(inputCode);
      outputEditor.setValue(deobfuscated, -1);
      updateLogs(logs);
      updateUrls(urls);
    });
  </script>
</body>
</html>
